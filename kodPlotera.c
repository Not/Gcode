#pragma config(Sensor, S1,     led,            sensorCOLORNONE)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

int xt=4300,yt=6400,xl=4300,yl=6400;
float l1=0,l2=0,t=0,tmax=0,dlu,diffc=0,diffb=0;
int h=8600,d=8600,obr=0;
int v=350;
int postep=0;
int rozmiar=13;
char polecenie='m';
bool rysuj=false;
bool test=false;
int tryb=0;
float z=1.0;

void checkBTLinkConnected();




	void ustawpisak(int ai)
	{
		if ((rysuj&&ai==0)||!rysuj&&ai==1||ai==2)
		{

			if (!test)
			{
			obr++;
			wait10Msec(20);
			while (nMotorEncoder[motorA] < obr*180) {motor[motorA] = 50;}
			}
			rysuj=!rysuj;
			motor[motorA] = 0;
			wait10Msec(20);
		}

	}

void ruch(int ax, int ay,int ai, int av)
{
	ustawpisak(ai);
	dlu=sqrt(pow(xl-ax,2)+pow(yl-ay,2)); //dlugosc lini
	tmax=dlu/av*1.0;																		 //czas ruchu
	ClearTimer(T1);
	while(time1[T1]/1000.0<tmax)											 //wykonywanie ruchu w czasie tmax
		{
		t=time1[T1]/1000.0;

		xt=xl+((ax-xl)/dlu)*t*av*1.0;              //wspolrzedne w czasie t
		yt=yl+((ay-yl)/dlu)*t*av*1.0;

		l1 = sqrt(pow((h - yt),2) + pow(xt,2));          //dlugosci sznurkow
		l2 = sqrt(pow((d - xt),2) + pow(h-yt,2));

		diffc=(z*nMotorEncoder[motorC]+4830*1.74)-l2*1.74;
		diffb=(z*nMotorEncoder[motorB]+4830*1.74)-l1*1.74; //48.3 = dlugosc na poczatku
		//nxtDisplayCenteredTextLine(4, "%d %d",diffb,diffc);
	 //nxtDisplayCenteredTextLine(5, "%d %d",diffb,diffc);
   //nxtDisplayCenteredTextLine(6, "%d %d",xt,yt);
	 //nxtDisplayCenteredTextLine(7, "%.2f %.2f",l1,l2);
		if(rysuj)nxtSetPixel(93-round(xt/100.0), 64- round(yt/100.0));

		motor[motorC]=-z*diffc*1.5;
		motor[motorB]=-z*diffb*1.5;
		}
xl=xt;yl=yt;
motor[motorC]=0;
motor[motorB]=0;
}

void rysujzpliku(string sFileName,int av)
{
	eraseDisplay();
	postep=0;

	TFileHandle   hFileHandle;
  TFileIOResult nIOResult;
  int size=50; //??
  bool niekoniec=true;
  int i=0;

  char incommingChar=48;
  OpenRead(hFileHandle, nIOResult, sFileName, size);
  //ReadByte(hFileHandle, nIOResult, incommingChar);//CF
 //ReadByte(hFileHandle, nIOResult, incommingChar);//LF
  int x=0, y=0;

  	while(niekoniec)
    {
    	postep++;

    x=0;y=0;
  	for(int k=0;k<4;k++)
    	{
    	ReadByte(hFileHandle, nIOResult, incommingChar);
    	if(incommingChar==13||incommingChar==11){ /*nxtDisplayCenteredTextLine(6,"koniec");*/ tryb=6; wait10Msec(60); eraseDisplay();Close(hFileHandle, nIOResult); return;}
    	x+=pow(10,3-k)*(incommingChar-48);
    	}
 		ReadByte(hFileHandle, nIOResult, incommingChar); //spacja

 		for(int k=0;k<4;k++)
    	{
    	ReadByte(hFileHandle, nIOResult, incommingChar);
    	y+=pow(10,3-k)*(incommingChar-48);
    	}
    ReadByte(hFileHandle, nIOResult, incommingChar); //spacja
    ReadByte(hFileHandle, nIOResult, incommingChar); //czy rysuj
    i=incommingChar-48;
    ReadByte(hFileHandle, nIOResult, incommingChar);//CR
	  //if(incommingChar!=13) {niekoniec=false; }
    ReadByte(hFileHandle, nIOResult, incommingChar);//LF
		if (polecenie=='z'){tryb=5; wait10Msec(60); eraseDisplay();Close(hFileHandle, nIOResult); return;}
    ruch(x,6400-y,i,av);

    }
Close(hFileHandle, nIOResult);
}

void zapiszdopliku()
{
	int n=0;

	eraseDisplay();
	TFileHandle   hFileHandle;
  TFileIOResult nIOResult;
  unsigned short filesize=32000;
  Delete("temp.txt",nIOResult);
  OpenWrite(hFileHandle, nIOResult, "temp.txt", filesize);
  ubyte BytesRead[1];
  int nLastCharReceived=0;
  int nNumbBytesRead;
	//nxtDisplayString(1,"odbieranie %d",(nLastCharReceived));
	nxtDisplayCenteredTextLine(1,"Odbieranie");
	while (true)
	{

		nxtDisplayCenteredTextLine(2,"%d",n/13);
  	nNumbBytesRead = nxtReadRawBluetooth(&BytesRead[0], 1);

	  if (nNumbBytesRead == 0)
	  {
	  	wait1Msec(10);
	  	continue;
	  }
	  nLastCharReceived = BytesRead[0];
	  if(BytesRead[0]=='x')
	  {
		  Close(hFileHandle, nIOResult);
		 	nxtDisplayTextLine(5,  "Zakonczono");
		 	//StopTask(zapiszdopliku);
		 	rozmiar=n/13;
		 	return;
	  }
	  WriteByte(hFileHandle, nIOResult, nLastCharReceived);
	  n++;


	}
}


void ustawbt()
{
	bNxtLCDStatusDisplay = true;
	setBluetoothOn();
	setBluetoothRawDataMode();
	while (!bBTRawMode)
	{
		wait1Msec(1);
	}
	bBTSkipPswdPrompt = true;
}

void checkBTLinkConnected()
{

	if (nBTCurrentStreamIndex >= 0)
	  return;

	tryb=1;
	PlaySound(soundLowBuzz);
	PlaySound(soundLowBuzz);
	eraseDisplay();
	nxtDisplayCenteredTextLine(3, "BT nie");
	nxtDisplayCenteredTextLine(4, "Polaczony");
	wait10Msec(300);

	StopAllTasks();
}


task watchbt()
{
	ubyte BytesRead[1];
  int nLastCharReceived=0;
  int nNumbBytesRead;

	while (true)
	{
  	nNumbBytesRead = nxtReadRawBluetooth(&BytesRead[0], 1);

	  if (nNumbBytesRead == 0)
	  {
	  	wait1Msec(10);
	  	continue;
	  }
	  nLastCharReceived = BytesRead[0];
	  nxtDisplayString(0,"%d", nLastCharReceived);

	 polecenie=nLastCharReceived;
	wait10Msec(20);


	}
}
 task ledy ()
 {
  while (true)
  {
  	switch (tryb)
		{
			case 0:
			SensorType[led] = sensorCOLORNONE;
			wait10Msec(100);

			break;
			case 1: //BT blad
			SensorType[led] = sensorCOLORBLUE;
			wait10Msec(50);
			SensorType[led] = sensorCOLORRED;
			wait10Msec(50);
			break;
			case 2: //oczekiwanie
			SensorType[led] = sensorCOLORBLUE;
			wait10Msec(50);
			SensorType[led] = sensorCOLORNONE;
			wait10Msec(200);
			break;
			case 3: //BT busy
			SensorType[led] = sensorCOLORBLUE;
			wait10Msec(10);
			SensorType[led] = sensorCOLORNONE;
			wait10Msec(10);
			break;
			case 4: //rysuj
			SensorType[led] = sensorCOLORBLUE;
			wait10Msec(70);
			SensorType[led] = sensorCOLORGREEN;
			wait10Msec(70);
			break;
			case 5: //czerwony
			SensorType[led] = sensorCOLORRED;
			wait10Msec(50);
			break;
			case 6: //zielony
			SensorType[led] = sensorCOLORGREEN;
			wait10Msec(50);
			break;
			case 7: //niebieski
			SensorType[led] = sensorCOLORBLUE;
			wait10Msec(50);
			break;
			case 8: //biay
			SensorType[led] = sensorCOLORFULL;
			wait10Msec(50);
			break;
			default:
			wait10Msec(50);
			break;

	  }
	  //wait10Msec(50);
 }
}
task send()
{

	int i=0;
	int procent=0;
	 char nMsgXmit[8]={'a','b','c','d','e','f','g','h'};
	while(true)
	{
		int poziom=nImmediateBatteryLevel;
		static ubyte BytesToSend[8];

		procent=(1.0*postep)/rozmiar *100;
		nMsgXmit[0]=poziom/1000 +48;
		nMsgXmit[1]=((poziom/100)%((poziom/1000)*10)) +48;
		nMsgXmit[2]=((poziom/10)%(poziom/100))+48;
		//nMsgXmit[3]=((poziom)%(poziom/10))+48;
		nMsgXmit[3]=procent/10 +48;
		nMsgXmit[4]=(procent-((procent/10) *10)) +48;
		nMsgXmit[5]=polecenie;



			if (bBTBusy)
			{
				wait1Msec(10);
			}

		memcpy(&BytesToSend, &nMsgXmit, sizeof(BytesToSend));
	//	memset(&BytesToSend, nMsgXmit[0], sizeof(BytesToSend));

	//	nxtDisplayString(5,"%c %c",nMsgXmit[3],nMsgXmit[4]);

		nxtWriteRawBluetooth(&BytesToSend[0], sizeof(BytesToSend));
		wait10Msec(100);
		i++;
	}
}

task main()
{

nMotorEncoder[motorA] = 0;
nMotorEncoder[motorC] = 0;
nMotorEncoder[motorB] = 0;
ustawbt();
//
StartTask(ledy,7);
checkBTLinkConnected();
StartTask(watchbt);
StartTask(send);
wait10Msec(100);
string nazwa = "temp.txt";


///*
nxtDisplayString(0,"Gotowosc");
while(true)
{
 if(nNxtButtonPressed==1)
 {
		while(nNxtButtonPressed==1)
		{
				motor[motorC]=-z*50;

		}
		motor[motorC]=0;

	}
	if(nNxtButtonPressed==2)
 {
		while(nNxtButtonPressed==2)
		{
				motor[motorB]=-z*50;

		}
		motor[motorB]=0;

	}

	switch (polecenie)
	{
		case 'u':              //zapis
		StopTask(watchbt);
		tryb=3;
		zapiszdopliku();

		StartTask(watchbt);
		//rysuj
		break;

		case 'i':

		tryb=4;
		if (test)
		rysujzpliku(nazwa,9000);
		else
		rysujzpliku(nazwa,v);
		polecenie='m';
		break;

		case 'q':

		ruch(4300,6400,1,v);
		polecenie='m';
		break;

		case 'e':

		ustawpisak(2);
		polecenie='m';
		break;

		case 'w':ruch(xt,yt+400,3,v);polecenie='m';break;
		case 'a':ruch(xt-400,yt,3,v);polecenie='m';break;
		case 's':ruch(xt,yt-400,3,v);polecenie='m';break;
		case 'd':ruch(xt+400,yt,3,v);polecenie='m';break;

		//case 'z':StopAllTasks();return;break;

		case '<':
		v-=50;
		nxtDisplayString(7,"v=%d mm/s",v/100);
		wait10Msec(20);
		polecenie='m';
		break;

		case '>':
		v+=50;
		nxtDisplayString(7,"v=%d mm/s",v/100);
		wait10Msec(20);
		polecenie='m';
		break;

		case 'l': StartTask(send);	polecenie='m'	;tryb=6;	break;
		case 'k':	StopTask(send);	polecenie='m';break;
		case 't':	test=!test;	polecenie='m';tryb = 5; wait10Msec(70);break;
		default:	tryb=2;	nxtDisplayString(1,"nieznana\nkomenda ");	wait10Msec(100);	eraseDisplay();	break;
		case 'm':	tryb=2;	nxtDisplayString(0,"Gotowosc")	;wait10Msec(20);	break;



	}
	wait10Msec(20);
	eraseDisplay();

}
//*/
//StopAllTasks();
}
